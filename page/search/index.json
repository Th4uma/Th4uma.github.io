[{"content":" 本项目复刻自立创开源 时间线变动仪-SQUIRRELMEDIA ,项目初始作者是bilibili用户 @遗落之沙\n今年2月产生了想制作一个《命运石之门》中世界线变动率探测仪的想法，上网查资料后了解到可以做成时钟并还原外观，于是开始复刻开源项目，目的是学习电子制作基础并作为自己的第一个作品。本项目基于51单片机制作，采用寿命较长，市面存量较大，外观较还原的IN-14辉光管\n物品清单 名称 作用 数量 IN-14辉光管 显示数字 8 CR1220-2 制作过程 1.eda平台打板 由于嘉立创只能免费打10*10以内的板，我选择了捷配，板子到手如下：\n2.焊接 第一次焊接贴片元件，不太熟练，经过\n3.测试并烧录程序 4.组装 ","date":"2025-06-29T01:26:20+08:00","permalink":"https://Thaumazein.github.io/post/nixie_tube/","title":"[001号机]辉光管时钟开源项目复刻"},{"content":"环境搭建 需要准备 ESP32、杜邦线、USB 转 TTL 模块、支持监听模式的无线网卡\n克隆源码\n1 git clone https://github.com/xuanxuanblingbling/esp32ctf_thu.git 安装esp-idf 安装好后打开ESP-IDF v4.3 PowerShell\n1 2 cd esp32ctf_thu/thuctf/ idf.py menuconfig 设置Serial flasher config ---\u0026gt; Flash size (4 MB) ,Partition Table ---\u0026gt; Partition Table (Custom partition table CSV)，然后保存 编译,烧录,监听串口输出 1 2 3 idf.py build idf.py flash idf.py monitor esp_no_flag_source目录中是删掉flag的源码，可以用来分析，但不能烧录\n上电前连接GND与23号引脚进入硬件、网络、蓝牙题目，否则默认进入MQTT题目，已供电时可按 EN 键重启使设置生效。\n硬件 task1 将GPIO18抬高，持续3s即可获得flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define GPIO_INPUT_IO_0 18 void hardware_task1(){ int hit = 0; while(1) { printf(\u0026#34;[+] hardware task I : hit %d\\n\u0026#34;,hit); if(gpio_get_level(GPIO_INPUT_IO_0)){ //判断gpio18是否为高电平 hit ++ ; }else{ hit = 0; } if(hit\u0026gt;3){ printf(\u0026#34;[+] hardware task I : %s\\n\u0026#34;,hardware_flag_1); break; } vTaskDelay(1000 / portTICK_RATE_MS); //这个任务每秒检测一次 GPIO 状态 } } 题目意思是GPIO18 引脚的电平保持为高电平（也就是接 3.3V或5v），时间要持续大于 3 秒，程序就会打印出 flag。 GPIO（General Purpose Input/Output）是通用输入输出引脚。可以配置成读取外部电平（输入模式）或控制外设（输出模式）。\nESP32 上的 GPIO 是多功能的，每个引脚都可以自由配置成输入、输出或其他特殊用途。\n用杜邦线连接3v3与GPIO18，持续3s即可\n此时hit增加，获得flag\nTHUCTF{Ev3ryth1ng_st4rt_fr0m_GPIO_!!!}\ntask2 在GPIO18处构造出1w个上升沿\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #define GPIO_INPUT_IO_0 18 #define GPIO_INPUT_PIN_SEL ((1ULL\u0026lt;\u0026lt;GPIO_INPUT_IO_0) ) static void IRAM_ATTR gpio_isr_handler(void* arg){ trigger++; // 每次触发中断时，trigger增加 } void hardware_gpio_setup(){ gpio_config_t io_conf; io_conf.pin_bit_mask = GPIO_INPUT_PIN_SEL; // 绑定 GPIO18 io_conf.mode = GPIO_MODE_INPUT; // 设置为输入模式 io_conf.intr_type = GPIO_INTR_POSEDGE; // 上升沿中断 io_conf.pull_up_en = 0; // 关闭上拉，初始状态是低电平 gpio_config(\u0026amp;io_conf); gpio_install_isr_service(ESP_INTR_FLAG_DEFAULT); // 开启中断服务 gpio_isr_handler_add(GPIO_INPUT_IO_0, gpio_isr_handler, (void*) GPIO_INPUT_IO_0); // 注册中断处理函数 } void hardware_task2(){ trigger = 0; while(1){ printf(\u0026#34;[+] hardware task II : trigger %d\\n\u0026#34;,trigger); if(trigger \u0026gt; 10000){ // 触发次数超过10000，输出flag printf(\u0026#34;[+] hardware task II : %s\\n\u0026#34;,hardware_flag_2); break; } vTaskDelay(1000 / portTICK_RATE_MS); } } 题目意思是要让 GPIO18 不断从低电平跳到高电平（上升沿），当次数大于 10000，程序就会打印出 flag 上升沿是电平从 0 变成 1 的瞬间。\nESP32 默认的 TX 引脚是持续发送数据的，它的电平会反复在高低之间切换。\n用杜邦线连接TX引脚与GPIO18，直到trigger\u0026gt;10000\nTHUCTF{AuT0++_is_th3_r1ght_w4y_hhhhhh}\n本质上任何能控制输出高低电平切换的引脚都可以用，甚至可以手动连接并断开GPIO18和其他引脚10000次（除了GND），还可以写一个任务让GPIO不断切换输出电平 task3 在另一个串口处寻找第三个flag\n1 2 3 4 5 6 7 8 9 10 11 #define ECHO_TEST_TXD (GPIO_NUM_4) // UART1 的 TX（发送）引脚是 GPIO4 #define ECHO_TEST_RXD (GPIO_NUM_5) // UART1 的 RX（接收）引脚是 GPIO5 void hardware_task3(){ printf(\u0026#34;[+] hardware task III : find the third flag in another UART\\n\u0026#34;); while (1) { // 向 UART1 发送一串字符串（hardware_flag_3），这个串口不会在 log 输出看到 uart_write_bytes(UART_NUM_1, hardware_flag_3, strlen(hardware_flag_3)); // 不断往 UART1 输出 flag vTaskDelay(1000 / portTICK_RATE_MS); } } 题目意思是要监听 UART1 的串口输出，即可直接读取 flag UART（通用异步收发器）是串口通信的一种协议，本质就是用两根线（TX 和 RX）来做点对点的串行通信。ESP32 上有多个 UART 通道。默认我们用的是 UART0，它用于 log 输出。但这里题目用的是 UART1。\n将USB 转 TTL 模块的RX引脚连接ESP的GPIO4引脚，gnd也对应连接\n用串口工具监听USB 转 TTL 模块\nTHUCTF{UART_15_v3ry_imp0r7ant_1n_i0T}\n网络 task1 连接板子目标端口，尝试获得flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void network_init(){ char ssid[0x10] = {0}; char pass[0x10] = {0}; get_random(ssid,6); //随机生成WiFi名称 get_random(pass,8); //随机生成密码 printf(\u0026#34;[+] network task I: I will connect a wifi -\u0026gt; ssid: %s , password %s \\n\u0026#34;,ssid,pass); connect_wifi(ssid,pass); //尝试连接到刚刚生成的WiFi } static void network_tcp() { char addr_str[128]; struct sockaddr_in dest_addr; dest_addr.sin_addr.s_addr = htonl(INADDR_ANY); // 接收任意IP dest_addr.sin_family = AF_INET; dest_addr.sin_port = htons(3333); // 监听3333端口 int listen_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 创建 TCP socket ESP_LOGI(TAG, \u0026#34;Socket created\u0026#34;); bind(listen_sock, (struct sockaddr *)\u0026amp;dest_addr, sizeof(dest_addr)); // 绑定 socket ESP_LOGI(TAG, \u0026#34;Socket bound, port %d\u0026#34;, 3333); listen(listen_sock, 1); // 开始监听 while (1) { ESP_LOGI(TAG, \u0026#34;Socket listening\u0026#34;); struct sockaddr_storage source_addr; socklen_t addr_len = sizeof(source_addr); int sock = accept(listen_sock, (struct sockaddr *)\u0026amp;source_addr, \u0026amp;addr_len); // 等待连接 inet_ntoa_r(((struct sockaddr_in *)\u0026amp;source_addr)-\u0026gt;sin_addr, addr_str, sizeof(addr_str) - 1); ESP_LOGI(TAG, \u0026#34;Socket accepted ip address: %s\u0026#34;, addr_str); char buffer[100]; while(recv(sock,buffer,0x10,0)){ // 接收数据 if(strstr(buffer,\u0026#34;getflag\u0026#34;)){ //如果内容包含getflag send(sock, network_flag_1, strlen(network_flag_1), 0); // 返回flag break; }else{ send(sock, \u0026#34;error\\n\u0026#34;, strlen(\u0026#34;error\\n\u0026#34;), 0); } vTaskDelay(1000 / portTICK_RATE_MS); } open_next_tasks = 1; shutdown(sock, 0); close(sock); } } 题目意思是ESP32 板子会随机生成一个WiFi 名（SSID）和密码，尝试连接这个热点。连上之后，它会在本地开启一个 TCP Server，监听端口 3333。需要在网络中找到并连接它，发送 getflag，它就会返回 flag。 STA 模式（Station）：ESP32 作为 WiFi 客户端接入热点。\nSocket 是一对网络通信端点，由 IP 地址 + 端口号组成。通过 socket 函数可以建立 TCP 或 UDP 连接，发送和接收数据。\nESP32 成功连接热点后，就成了局域网的一员，它的 3333 端口会接受来自其他设备的 TCP 连接。\nnetcat作用是快速建立 TCP 或 UDP 连接，用来读写数据。\n修改电脑的热点名称和密码与串口打印的相同\nesp32连接成功，获得ip地址192.168.137.188\nnc一下，输入nc 192.168.137.188 3333\ngetflag\nTHUCTF{M4k3_A_w1rele55_h0t5p0ts}\ntask2 你知道他发给百度的flag么\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void network_http() { char fmt[] = \u0026#34;GET / HTTP/1.0\\r\\n\u0026#34; \u0026#34;Host: www.baidu.com:80\\r\\n\u0026#34; \u0026#34;User-Agent: esp-idf/1.0 esp32\\r\\n\u0026#34; \u0026#34;flag: %s\\r\\n\u0026#34; \u0026#34;\\r\\n\u0026#34;; char request[200]; sprintf(request,fmt,network_flag_2); // 构造带有 flag 的 HTTP 请求头 const struct addrinfo hints = { .ai_family = AF_INET, .ai_socktype = SOCK_STREAM, }; struct addrinfo *res; struct in_addr *addr; int s; while(1) { if(open_next_tasks){ printf(\u0026#34;[+] network task II : send the second flag to baidu\\n\u0026#34;); getaddrinfo(\u0026#34;www.baidu.com\u0026#34;, \u0026#34;80\u0026#34;, \u0026amp;hints, \u0026amp;res); // DNS 解析 addr = \u0026amp;((struct sockaddr_in *)res-\u0026gt;ai_addr)-\u0026gt;sin_addr; ESP_LOGI(\u0026#34;network\u0026#34;, \u0026#34;DNS lookup succeeded. IP=%s\u0026#34;, inet_ntoa(*addr)); s = socket(res-\u0026gt;ai_family, res-\u0026gt;ai_socktype, 0); connect(s, res-\u0026gt;ai_addr, res-\u0026gt;ai_addrlen); // 建立 TCP 连接 freeaddrinfo(res); write(s, request, strlen(request)); // 发送 HTTP 请求 close(s); } vTaskDelay(10000 / portTICK_PERIOD_MS); } } 题目意思是板子把 network_flag_2 写在 HTTP 请求头里，然后发给百度的 80 端口，要拦截 ESP32 向百度服务器发送的 HTTP 请求，提取其中携带的 flag。 ESP32 用 socket 构造 HTTP 报文并发送，请求并不返回给本地终端，需要抓包分析出站流量。板子的网络行为都会从电脑出去，所以可以抓到 HTTP 请求\n电脑开启热点后，系统会新建一个虚拟网卡\n用wireshark抓取这个网卡的流量，追踪http流，发现flag\nTHUCTF{Sn1ffer_N3tw0rk_TrAffic_In_7h4_Main_r0aD}\ntask3 flag在空中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 static void network_wifi() {\t// 定义一段固定的原始802.11数据包（PDU），是Wi-Fi协议的数据帧格式 static const char ds2ds_pdu[] = { 0x48, 0x03, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0x65, 0xD4, 0xCB, 0x74, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x60, 0x94, 0xE8, 0x65, 0xD4, 0xCB, 0x74, 0x1C, 0x26, 0xB9, 0x0D, 0x02, 0x7D, 0x13, 0x00, 0x00, 0x01, 0xE8, 0x65, 0xD4, 0xCB, 0x74, 0x1C, 0x00, 0x00, 0x26, 0xB9, 0x00, 0x00, 0x00, 0x00, }; char pdu[200]={0}; // 在固定数据包后面拼接 flag 内容，形成完整的带 flag 的数据帧 memcpy(pdu,ds2ds_pdu,sizeof(ds2ds_pdu)); memcpy(pdu+sizeof(ds2ds_pdu),network_flag_3,sizeof(network_flag_3)); while(1) { if(open_next_tasks){ printf(\u0026#34;[+] network task III : send raw 802.11 package contains the third flag\\n\u0026#34;); esp_wifi_80211_tx(ESP_IF_WIFI_STA, pdu, sizeof(ds2ds_pdu)+sizeof(network_flag_3), true); // 通过 esp_wifi_80211_tx 函数，直接发送底层802.11无线数据包（裸包），不经过协议栈 } vTaskDelay(5000 / portTICK_PERIOD_MS); } } 题目意思是ESP32 直接构造并发送了一个原始的802.11数据包，包含了第三个flag的数据。捕获周围无线信号里的所有802.11帧，包括ESP32发出的这段含flag的裸包，然后用Wireshark解析，就能看到里面隐藏的flag。 802.11数据帧（Wi-Fi裸包）：无线局域网通信的底层数据单元，包含MAC地址、控制字段、负载等，不同于TCP/IP数据包。这种帧必须用支持监听模式的无线网卡开启监听模式后才能看到。\n监听模式无线网卡：捕获所有经过空中的无线帧，包括不发给自己的。普通Wi-Fi连接只能看到TCP/IP层数据，监听模式才能看到MAC层及以上的帧内容。\n把无线网卡插入kali，切换网卡到监听模式并开始监听\n1 2 sudo airmon-ng start wlan0 sudo airodump-ng wlan0mon wireshark抓wlan0mon网卡的包,在字节流中用字符串搜索CTF\n1 sudo wireshark THUCTF{YOu_cAn_s3nd_4nd_sNiff3r_802.11_r4w_pAckag3}\n蓝牙 task1 修改蓝牙名称并设置可被发现即可获得flag\n1 2 3 4 5 6 7 8 void check_name(char * a,char * b){ if(!strcmp(a,b)){ printf(\u0026#34;bluetooth task I : %s\\n\u0026#34;,bt_flag_1); esp_bt_gap_cancel_discovery(); scan = 0; next_task(); } } 字面意思，修改手机蓝牙名称与串口打印的相同，等待连接即可\nTHUCTF{b1u3t00th_n4me_a1s0_c4n_b3_An_aTT4ck_surfAce}\ntask2 flag在空中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void next_task(){ unsigned char fmt[]= {0x06,0x09,0x68,0x65,0x6C,0x6C,0x6F, sizeof(bt_flag_2),0xFD}; char client_name[10]={}; get_random(client_name,5); printf(\u0026#34;[+] bluetooth task II : BLE device name is %s\\n\u0026#34;,client_name);// 生成随机 BLE 广播设备名 printf(\u0026#34;[+] bluetooth task II : Please find the second flag in the ADV package from this BLE device %s\\n\u0026#34;,client_name); unsigned char data[100]; memcpy(data,fmt,sizeof(fmt)); memcpy(data+2,client_name,5); memcpy(data+sizeof(fmt),bt_flag_2,sizeof(bt_flag_2));// 将第二个 flag 添加到广播包末尾 // 配置 BLE 广播的原始数据，直接以二进制形式发送esp_ble_gap_config_adv_data_raw(data,sizeof(fmt)+sizeof(bt_flag_2)); // 开始广播 esp_ble_gap_start_advertising(\u0026amp;ble_adv_params); esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gatts_app_register(PROFILE_A_APP_ID); esp_ble_gatt_set_local_mtu(500); } 题目意思是ESP32 现在使用低功耗蓝牙广播模式，设备名是ivhti，flag 在 BLE 广播包里，通过监听广播拿到。 BLE 设备会周期性向外发送广播包，内容可以自定义。\nnRF Connect可用于扫描，调试低功耗蓝牙设备。\n用nRF Connect 抓取广播包，获得一串16进制数据5448554354467B416456443437617D\n转成ascii，获得flag\nTHUCTF{AdVD47a}\ntask3 分析GATT业务并获得flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 case ESP_GATTS_WRITE_EVT: { // 当手机等客户端向蓝牙设备写数据时，会触发这个事件 ESP_LOGI(GATTS_TAG, \u0026#34;GATT_WRITE_EVT, conn_id %d, trans_id %d, handle %d\u0026#34;, param-\u0026gt;write.conn_id, param-\u0026gt;write.trans_id, param-\u0026gt;write.handle); if (!param-\u0026gt;write.is_prep){ ESP_LOGI(GATTS_TAG, \u0026#34;GATT_WRITE_EVT, value len %d, value :\u0026#34;, param-\u0026gt;write.len); esp_log_buffer_hex(GATTS_TAG, param-\u0026gt;write.value, param-\u0026gt;write.len); // 打印写入的数据内容（十六进制） printf(\u0026#34;[+] bluetooth task III : %s\\n\u0026#34;,param-\u0026gt;write.value); // 打印收到的内容（字符串） // 检查写入的数据是否和第二个flag一样 if(!strncmp(bt_flag_2,(char *)param-\u0026gt;write.value,param-\u0026gt;write.len)){ printf(\u0026#34;[+] bluetooth task III : you can read the third flag this time\\n\u0026#34;); open_task3 = 1; // 如果正确，标记允许读第三个flag } } esp_ble_gatts_send_response(gatts_if, param-\u0026gt;write.conn_id, param-\u0026gt;write.trans_id, ESP_GATT_OK, NULL); break; } 题目意思是向 ESP32 的 GATT 服务写入flag2，如果写入正确，系统会提示你可以读第三个 flag 了，说明已经通过验证，然后就可以读取隐藏的 flag。 GATT（Generic Attribute Profile）是 BLE通信的一种通信规范,定义了BLE 设备之间如何组织数据和读写数据的规则。\n通过手机写入广播获取的 flag，实现对 BLE 特征值的访问控制。\n用nRF Connect连接上一题的BLE\n在Unknown Service\u0026gt;Unknown Characteristic中上传task2的flag\n读取获得字符串54-48-55-43-54-46-7B-57-72-49-74-45- 5F-34-5F-67-41-37-54-7D-00\n转ascii获得flag\nTHUCTF{WrItE_4_gA7T}\nMQTT 题目的域名到期了，需要构建一个MQTT服务器，docker文件夹里有这题的dokerfile，起一个docker，然后打开服务器1833端口\n1 2 docker build -t esp32ctf . docker run -d -p 1883:1883 esp32ctf 手机热点改成如下名称和密码，电脑和ESP32连接热点\n1 2 // MQTT connect_wifi(\u0026#34;THUCTFIOT\u0026#34;,\u0026#34;mqttwifi@123\u0026#34;); main.c这部分改成自己的域名，然后重新编译烧录\n1 mqtt_app_start(\u0026#34;mqtt://192.168.229.152\u0026#34;); 日志看到连接成功，打开mqtt.fx，设置broker为自己的ip和端口号并连接\ntask1 你知道MQTT的上帝是谁么\n1 2 3 4 5 6 switch (event-\u0026gt;event_id) { case MQTT_EVENT_CONNECTED: ESP_LOGI(\u0026#34;mqtt\u0026#34;, \u0026#34;MQTT_EVENT_CONNECTED\u0026#34;); // 向主题 \u0026#34;/topic/flag1\u0026#34; 发布一条消息，消息内容是 mqtt_flag_1 msg_id = esp_mqtt_client_publish(client, \u0026#34;/topic/flag1\u0026#34;, mqtt_flag_1, 0, 1, 0); printf(\u0026#34;[+] MQTT task I: publish successful, msg_id=%d\\n\u0026#34;, msg_id); 题目意思是ESP32 设备在连接 MQTT 成功后，会自动向 /topic/flag1 主题发送 flag，如果你作为 MQTT 客户端订阅了所有主题，就能收到这条 flag 消息 MQTT 协议是轻量级物联网通信协议，通过发布/订阅机制进行消息传递，适合嵌入式设备使用。\nBroker是MQTT 网络中的核心服务器，负责接收、转发所有客户端的消息。客户端通过订阅主题来接收由其他客户端发布到这些主题的消息。\n主题通配符：# 表示订阅所有主题，+ 表示匹配单层主题\nsubscribe输入#订阅所有主题，即可接收 broker 上发布的所有消息，看到flag\nTHUCTF{#_1s_God_in_MQTT}\ntask2 你能欺骗订阅者么\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void mqtt_data_hander(int length,char * data){ char l[10]; char url[500] = {0}; char out[500] = {0}; char httpdata[500]={0}; char flagdata[500]={0}; char tag3[] = \u0026#34; [+] MQTT task III: \u0026#34;; sprintf(flagdata,\u0026#34;%s%s%s\u0026#34;,mqtt_flag_2,tag3,mqtt_flag_3); // 构造完整的 flag 内容：flag2 + 提示语 + flag3 int a = 46; // 默认提取 flag 的长度 // 从 MQTT 数据中查找 \u0026#39;?\u0026#39;，分离 URL 与长度值 char * p = strnstr(data,\u0026#34;?\u0026#34;,length); if(p){ int data_length = p - data; // URL 部分的长度 snprintf(l,length - data_length,\u0026#34;%s\u0026#34;,p+1); // 把 ? 后的内容存入 l a = atoi(l); // 把 ? 后的字符串转成整数 a length = data_length; // 更新长度，截掉问号部分 } sprintf(url,\u0026#34;%.*s\u0026#34;,length, data); // 提取 URL // 构造 HTTP 请求，请求头中包含 flag 前 a 字节内容 char fmt[] = \u0026#34;GET / HTTP/1.0\\r\\n\u0026#34; \u0026#34;User-Agent: esp-idf/1.0 esp32\\r\\n\u0026#34; \u0026#34;flag: %s\\r\\n\u0026#34; \u0026#34;\\r\\n\u0026#34;; if( a \u0026lt; (int)(sizeof(mqtt_flag_2) + sizeof(tag3) - 1 ) ){ memcpy(out,flagdata,a \u0026amp; 0xff); sprintf(httpdata,fmt,out); // 插入 a 长度的 flag 内容 http_get_task(url,httpdata); // 向指定 URL 发送 HTTP 请求 } } case MQTT_EVENT_DATA: ESP_LOGI(\u0026#34;mqtt\u0026#34;, \u0026#34;MQTT_EVENT_DATA\u0026#34;); printf(\u0026#34;[+] MQTT task II: topic -\u0026gt; %.*s\\r\\n\u0026#34;, event-\u0026gt;topic_len, event-\u0026gt;topic); printf(\u0026#34;[+] MQTT task II: data -\u0026gt; %.*s\\r\\n\u0026#34;, event-\u0026gt;data_len, event-\u0026gt;data); mqtt_data_hander(event-\u0026gt;data_len,event-\u0026gt;data); break; 题目意思是ESP32 作为 MQTT 客户端，订阅了主题，向该主题发送一条消息，只要内容是一个 IP 地址，ESP32 收到后会主动向这个 IP 发起 HTTP 请求，请求中带有部分 flag 内容，藏在 flag: 请求头中，截取长度默认46，如果消息中包含?数字，长度会被更改 攻击者通过发布特定消息控制设备发起 HTTP 请求，将 flag 内容泄露到外部服务器。\n设备未验证 MQTT 消息合法性，导致攻击者可控制其对任意地址发起请求。\nHTTP 默认使用 80端口\n向flag2主题发送ip，nc监听80端口即可\nnc -l -p 80\nTHUCTF{attAck_t0_th3_dev1ce_tcp_r3cV_ch4nnel}\ntask3 这是个内存破坏的前戏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 sprintf(url,\u0026#34;%.*s\u0026#34;,length, data); // 提取 URL // 构造 HTTP 请求，请求头中包含 flag 前 a 字节内容 char fmt[] = \u0026#34;GET / HTTP/1.0\\r\\n\u0026#34; \u0026#34;User-Agent: esp-idf/1.0 esp32\\r\\n\u0026#34; \u0026#34;flag: %s\\r\\n\u0026#34; \u0026#34;\\r\\n\u0026#34;; if( a \u0026lt; (int)(sizeof(mqtt_flag_2) + sizeof(tag3) - 1 ) ){ memcpy(out,flagdata,a \u0026amp; 0xff); sprintf(httpdata,fmt,out); // 插入 a 长度的 flag 内容 http_get_task(url,httpdata); // 向指定 URL 发送 HTTP 请求 } } 题目意思是需要让a的值大于字符串长度才可获得flag，但a \u0026lt; (int)(sizeof(mqtt_flag_2) + sizeof(tag3) - 1限制了a的大小，memcpy(out,flagdata,a \u0026amp; 0xff)是与运算，表示取a的二进制的最低8位。因此a=-1时，二进制是11111111 11111111 11111111 11111111，a \u0026amp; 0xff = 00000000 00000000 00000000 11111111 = 255，且a=-1可通过长度判断 \u0026amp; 0xff 是按位与运算，常用来截取整数的二进制最低8位，对负数（补码全1）做 \u0026amp; 0xff 操作，得到的是255。\n判断时没有验证符号导致安全漏洞。\n向flag2主题发送ip?-1，nc监听80端口即可\nTHUCTF{0ver_the_Air_y0u_c4n_a77ack_t0_1ntranet_d3v1ce\n参考 ESP32 IoT CTF 清华校赛版 Write Up | Clang裁缝店\nESP32 IoT CTF 题解-腾讯云开发者社区-腾讯云\n","date":"2025-06-28T13:26:44+08:00","image":"https://Thaumazein.github.io/images/esp0.jpg","permalink":"https://Thaumazein.github.io/post/espthuctf/","title":"ESP32 IoT CTF 清华校赛版wp"},{"content":"不知不觉大一已经结束，还有两个月就要变成中登了，有些压力。这一年学的东西并不多，但还是有不少收获，主要是心态方面的转变\n心理篇 ——一句话总结，就是无尽的焦虑和痛苦 。\n噩梦的开始 ​\t没能进到心仪的信息安全专业，而是被录取到了电子商务，这是我想都没想过的。曾经梦想中和从他人口中得知的大学是时间自由，可以尽情学喜欢东西的地方。但现实是每天上着空洞又没价值的课，看到所有系统里自己的专业都是电子商务，心里慢慢只剩下恶心。以前只是觉得这个专业没什么技术含量，现在完全变成了我最不想提起的存在\n​\t尽管如此，我还是有希望逃离这里。学校一共有3次转专业机会，完全可以转入自己喜欢的专业，但是有一个致命的问题：本专业成绩好才能转。要成绩好就只能忍着恶心浪费时间在不喜欢的东西上，一上不喜欢的课就加重焦虑和痛苦，严重的焦虑导致我难以集中精力，反而没心思学习。再加上家乡和浙江的教育资源、高考压力不一样，我一入学就落后其他同学不少，这让我的希望逐渐渺茫。\n​\t就这样陷入了恶性循环，焦虑了一整学期，基本没学进去什么，也几乎失去了希望，慢慢变得一遇到问题就怪环境，对别人要求高，对自己却总找借口，遇到困难第一反应就是躺平。就这样，不愿再次回想的大一上学期结束了。\n一丝希望 ​\t大一结束就可以报名转专业了，我一共报名了三种，普通，卓越和双学位。命运给我了一个好机会，学校新开的这个双学位专业里面包含信息安全，而我在寒假奇迹般的以9/10的排名被录取，可喜可贺。\n迷茫与后悔 ​\t虽然转了专业，但新专业的课程是一半网安一半管理。无论是课程中，还是专业名称中，抑或是我所属的管理学院中，一看到管理，我就能会想起之前的痛苦，感受到强烈的恶心。我开始迷茫到底应该继续转专业还是留在这里，同时对上学期被浪费掉感到焦虑。曾经参加过那么多比赛，几乎每次都可以拿到前几名，当时积累的让我引以为傲的编程能力，科技创新能力现在渐渐被人赶超，这让我越来越自卑，不愿接受自己已经泯然众人的事实。尽管已经脱离了困境，但我的焦虑也并没有被缓解，只有痛苦减轻。\n​\t我也开始承担上学期恶习导致的恶果，这学期整个人变得过于松懈，注意力差、做事没耐心、不愿动脑思考，这些问题没随着压力减轻而好转，而是将我拖向深渊，每天上课提不起劲，还总是打着自学的幌子玩手机，自己都觉得难以接受。不过唯一的进步就是心情变好，也有心思自学一些东西，研究自己的爱好了(^_^)。就这样，浑浑噩噩的大一下学期结束了\n改变 ​\t从寒假开始就已经有改变现状的想法，但一想到改变，就想到之前浪费的时光、和他人的差距、自己的失败，所以一次次焦虑，给自己找借口，导致整整一学期我的改变都微乎其微。期末，我突然觉得如果再不真正做出改变，就彻底赶不上其他人了，美好的大学生活也将离我而去。至于改变的方法，由于之前学习完都只留下记忆，非常虚无缥缈，而且如果忘记，就和没有学过差不多，因此我选择了写博客记录下学习的过程。\n​\t我认为仅仅过完了一个大一，时间还来得及，我不再跟那些社团里的大佬比较，专注提升自己，哪怕最后不如他们，也比现在这样更好。现在想想，我注重知识的广度，他们注重知识的深度，也许我并不落后于他们，只是我没发现罢了。\n当局者迷 也许我上面所提到的状态差、焦虑，都是我为自己的懒惰找的借口也说不定，这件事的答案我目前无从得知。\n社团篇 今年上半学期，加入了0RATYS和航模社，这既是我的希望与梦想，也是我一部分的痛苦来源。\n航模 加入 ​\t入社考核分为两次，一次是飞手选拔，一次是方向选择。第一次考了sw画火火箭和cad画fpv，还有最重要的模拟器。\n​\t我是初中就玩过固定翼的究极老登，虽然玩了好几年连一个航线都飞不下来，再加上多年没碰，但依旧手感爆发，第一次训练飞完航线，之后甚至练会了倒飞，最后理所当然的模拟器分数第一，总分前几。这是我设计的火火箭和fpv\n​\t然后就是分方向，我这种情况按理说很适合玩固定翼，我也很喜欢，但是高中就憧憬fpv，感觉fpv又好玩又帅，再说了立的flag总得实现一个吧，于是就选了微折。结果进群后发现5人只能进2人。当时听说固定翼组依旧统一训练，暂时不细分方向，我就一直以为被微折淘汰掉就跟固定翼一起训练了，后面才知道淘汰就寄了，好险😨。\n​\t当时其实并没有抱太大希望能进组，因为同组有两个同学有基础，训练时非常熟练。另外两个同学选择了退出，我也被组长劝退过，但我不服输，还是坚持下来。最终考核有模拟器，焊接，理论，模拟器我不如别人，没有时间加分，但我保证没扣基础分，焊接训练时我拿到了98高分，大概是手比较稳，理论分数不高，由于我当时有些失去希望，就没有准备。但最后我居然以0.2的分差超过了最后的同学进来了，最幸运的一集。\n练习 ​\t成功加入后就是每周去航模室训练，3月我第一次学会设置飞机，然后第一次飞了真机。练了一个月悬停，终于从一飞就炸机到稳定悬停。月底第一次戴眼镜飞行，没过多久·，4月初我就有了自己的第一架fpv\n5月初，我感觉目前用顶级的图传有些没必要而且浪费，再加上总担心炸坏，于是把o4pro拆下来卖了换成小o4，还有了自己的工位。暑假即将开始半个月的训练，我会把这项爱好一直坚持下去\n网安 加入前 迷茫 ​\t高中就超级坚定大学要学网安，入学以后自然是要加入网安社，其实刚开始想加vidar的，也听了他们的几次讲座，本来0rays的讲座也想听，但那几次我总是刚好有事（悲，最后还是选了0rays。然后就是迷茫，因为感觉其他同学都学的好快，懂得好多，我不知道从何学起，也不好意思和社团里的同学交流，再加上这学期的心态问题，导致一学期就学了一些简单的misc基础，然后工作室也不好意思去，大概是感觉自己去了尴尬，而且什么都不会去了没事干，也没有熟人，每次比赛就阴暗的窝在寝室看别人解题，想自己试试发现跟不上，不会，所以基本都是负反馈，有点难受(´°̥̥̥̥̥̥̥̥ω°̥̥̥̥̥̥̥̥｀)，既然这样干脆就不要纠结这个比赛了，把目光放在学习本身。我想了想，无人机，网安，电子制作是我喜欢的东西，那么我现在应该利用我的兴趣，所以我决定学iot安全，等我成为大佬，能不能把iot安全和无人机结合起来呢（又立flag。就这样开始了，问了学长说让我复现清华的esp题目，于是我就先买东西然后看了esp的教程，想看完教程再复现，但我发现这样根本记不住，学习方法有问题，于是我决定先跟着wp做一遍，然后让gpt帮我一点点分析代码，顺便学习。现在已经做了一半了，等期末月结束就继续。不得不提一个有趣的东西，上学期和现在的espctf我都接触了kali渗透的题目，要用到无线网卡，而高一我还在幻想成为大黑客的时候，就买了一个无线网卡破解别人wifi，虽然最后没有成功（黑历史加一，而现在我用的这块网卡，还是从高一继承下来的。这个过程中，我又开始动手做寒假本来准备这学期开学做的东西，辉光管时钟。虽然是花式点灯，但我真的一点也不会，所以打算先复刻开源项目练手，之后再自己设计。经过一个月的看视频和研究，我打好了pcb板，买好了元件，也焊接了一半，打算暑假把这个项目做完，打下这些基础，对我的安全学习应该会有帮助吧。\n总体上来看这学期对航模的学习还是挺不错的，跟上了进度，也进步很多，但网安方面我对自己并不满意，如果高中的我看到现在的我，一定会说你这一年都在干什么，我的梦想被你搞砸了。那么下学期多多加油，课上的时间用来写博客和复盘，空闲时间用来学习。 暑假安排 fpv训练，这是最主要的 把半截项目做完 宿舍网络与设备的方案做好，最好能施工完成 做做攻略，去日本玩一趟 如果还有时间，找一个学习iot安全的切入点吧 把一玩手机就停不下来的坏毛病改了，尽量人机分离\n学习篇 成果 sw基本使用 ctf misc基础 手机root fpv飞行 esp32thuctf复现 （一半） 跟着大佬们打了几个ctf比赛（基本不会） 第一个电子制作项目辉光管时钟（开源复刻）（一半） 想学 主流编程语言不会的学会，会的熟练使用，现在基础不行 电子制作入门，先浅显学一下51，小时候玩过很长时间arduino uno，用的图形化编程，一下让我学esp32有些不习惯，主要是freertos不熟悉（还是菜和懒）（笑 ctf要抓紧学习了，已经比其他同学落后一年了，不求打出成绩，只是我当时打这个比赛的初衷要实现，也就是学知识！落后不要紧，开始最重要 街攀（优先级低）高中曾经幻想我一上大学就要学各种东西，其中就有街攀。天天幻想成为街攀高手，结果马上大二了连拿爱车练定车都还没开始，如果航模之后比赛能拿个好成绩，就把fpv练习时间拿一部分给街攀 跑酷（遥远）先脱离现在这个死宅样子再说吧\n暑假安排 fpv训练 espctf复现完成 辉光管时钟做完 宿舍网络与设备的方案做好，最好能施工完成 做攻略，去日本玩一趟 刷iot安全的题 把一玩手机就停不下来的坏毛病改了 ","date":"2025-06-26T12:05:13+08:00","image":"https://Thaumazein.github.io/images/zj0.jpg","permalink":"https://Thaumazein.github.io/post/2025/","title":"[随记]2025大一总结"},{"content":" 具体博客搭建过程见Hugo + Github博客搭建记录\n评论 ","date":"2025-06-25T20:03:02+08:00","image":"https://Thaumazein.github.io/images/hugon00.jpg","permalink":"https://Thaumazein.github.io/post/hugo_new/","title":"Hugo 博客功能拓展"},{"content":"环境准备 下载hugo\n将 Hugo 解压路径添加至系统 PATH\n注册GitHub 下载Git 搭建博客 创建站点 hugo目录下打开命令行，输入hugo new site blog，新建一个存放网站文件的文件夹，成功后出现提示\n主题配置 可以在Hugo Themes找到喜欢的主题，我用的是stack，下载后解压到blog\\themes目录里 在主题文件夹中找到exampleSite文件夹，复制其中content和hugo.yaml到blog文件夹下，并删除原本的配置文件hugo.toml 修改themes文件夹下主题文件名，删除文件名中的版本号，使其和hugo.yaml中的主题名一样 删除content\u0026gt;post\u0026gt;rich-content文件夹，因为文件内容引用了youtube视频，不删掉可能网络访问失败启动不了 此时网站框架完成，输入hugo server --buildDrafts命令启动服务，打开输出的地址，如http://localhost:1313/，就可以看到网站的框架了 主要文件夹 文件夹 功能描述 assets 放置图标、JS 脚本、CSS 样式等资源 content 存放文章与页面，如博客、分类、归档等 layouts 页面结构与布局模板 public Hugo 编译输出目录，不建议手动修改 static 静态文件，如图片等，会直接映射到根路径 themes 主题文件夹 content文件夹中：\ncategories是分类页面目录 page是归档、友链、关于等页面的目录 post是存放博客文件的目录 新建文章 blog\\content\\post文件夹用来存放文章\n命令行输入hugo new content post/myfirstblog/index.md\nmd文件名的后缀是语言编码，如index.en.md在英文环境，index.zh-cn在中文环境，默认使用 index.md 即可\n注：文章中图片引用绝对路径会报错，因此在static文件夹下新建一个images文件夹，把文章中用到的图片放进去，改名使图片名中不含空格，引用时![图片名](/images/图片名)或\u0026lt;img src=\u0026quot;/images/图片名\u0026quot; style=\u0026quot;width: 缩放百分比%;\u0026quot; /\u0026gt;\n基本参数设置 注：改动参数时要在:后面加一个空格，否则会报错\n外观设置 修改hugo.yaml文件，主要参数如下：\n1 2 3 4 5 baseurl: https://example.com/ #网站地址 languageCode: zh-cn #网站使用的语言代码 theme: hugo-theme-stack\t#主题 title: Thaumazein\u0026#39;s blog #网页标题 copyright: Thaumazein #自己的名字 DefaultContentLanguage: 默认语言\nhasCJKLanguage: 设置为true\n1 2 3 4 5 6 7 8 9 #里面的模块可以删掉不需要的语言 languages: zh-cn: #留下中文就可以 languageName: 中文 title: Thaumazein #改成自己的名字 weight: 2 params: sidebar: subtitle: 404 Not Found #简介 pagination: pagerSize: 5:每页文章数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 params: mainSections: - post featuredImageField: image rssFullContent: true favicon: /favicon.ico #网站小图标，将图片转换成`favicon.ico`，放在`static`目录下，然后将这个值设置为`/favicon.ico` footer: since: 2025 #创建时的年份 customText: \u0026#34;May you find your worth in the waking world.\u0026#34; #网站底下的小字 dateFormat: published: \u0026#34;2006-01-02\u0026#34; #格式改成年份-月份-日期，如2006-01-02 lastUpdated: \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; sidebar: emoji: 😋 #头像旁边的表情 subtitle: avatar: enabled: true local: true src: img/avatar.png #头像，将150*150，png格式图片放在\\hugo\\blog\\assets\\img目录下，改名avatar.png article: math: true #数学公式 toc: true readingTime: false license: enabled: true default: \u0026#34;Licensed under CC BY-NC-SA 4.0\u0026#34; 注：头像和简介改完如果没有变化，输入hugo --gc清理一下缓存再重新启动服务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 widgets: #页面右侧功能 homepage: - type: search #搜索 - type: archives #归档 params: limit: 5 - type: categories #类别 params: limit: 10 - type: tag-cloud #标签云 params: limit: 10 page: - type: toc 主页Archives,Search,Links显示英文解决方法:hugo\\blog\\content\\page文件夹中对应名称的文件夹，打开其中的index.md,修改成中文标题 社交账号 可以自己增加平台账号，图标从Tabler Icons下载svg格式 在\\hugo\\blog\\assets目录下创建icons文件夹，放入图标，然后修改hugo.yaml文件这一部分 1 2 3 4 5 6 social:\t- identifier: github #改成平台名 name: GitHub #同上 url: https://github.com/Th4uma #改成对应平台url params: icon: brand-github #图标文件名 到这里本地的设置和调试基本完成了，网站现在是这样：\n部署到GitHub 手动部署 github新建一个公有仓库，命名建议github用户名.github.io 修改hugo.yaml文件baseurl参数为https://用户名.github.io/ 我们需要把public文件夹下的文件上传，因此在此文件夹下打开命令行，然后依次输入下列命令 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/Th4uma/Th4uma.github.io.git git push -u origin main 仓库界面进入settings\u0026gt;pages\u0026gt;branch选择main，保存，刷新后出现自己网站的url，部署成功 GitHub Action实现自动化部署 github新建一个仓库用来存放hugo主文件，建议设置成私有 由于自动生成的文件比如public不需要上传，因此在\\hugo\\blog文件夹新建一个.gitignore文件来忽略上传，文件中写入 1 2 3 public resources .hugo_build.lock 打开命令行，然后依次输入下列命令 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/Th4uma/hugo_main.git git push -u origin main 在Personal Access Tokens (Classic)新建一个token，设置如下\n进入存放hugo主文件的仓库，选择Settings\u0026gt; Secrets and variables\u0026gt; Actions\u0026gt;Repository secrets新增环境变量，填入token\n在\\hugo\\blog文件夹下新建.github\\workflows\\xxxx.yaml文件,复制下面的代码到文件，并把参数改成自己的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 把文件push上去 1 2 3 git add . git commit -m \u0026#34;update\u0026#34; git push 仓库中显示运行成功，部署完成 新增功能（持续更新） 见Hugo 博客功能拓展\n参考 b站up主Letere-莱特雷的视频与博客 https://morick66.com/post/20240321055915 ","date":"2025-06-24T11:24:02+08:00","image":"https://Thaumazein.github.io/images/hugo00.jpg","permalink":"https://Thaumazein.github.io/post/hugo_blog/","title":"Hugo + GitHub博客搭建记录"},{"content":"前言 最近复盘了一下过去一年的学习路线，发现很多知识都是学完就忘，效率不高，因此萌生了记录下自己学习过程与心路历程供以后阅读的想法，也希望借此看到自己的成长，故决定开始写博客。第一篇博客我将借助记录markdown语法的过程，熟悉写博客的基本流程。\nMarkdown基础语法 标题 # 的个数 = 标题级数，如 ### 标题 是三级标题\n引用 \u0026gt; + 内容，\u0026gt; 的个数等于嵌套级数\n这是引用\n列表 有序列表 n. + 内容，n 为序号\n111 222 无序列表 - 或 * + 内容\n111\n222\n任务列表 - [ ] + 内容，- [x] 表示已完成\n111\n111\n列表嵌套 子列表前加tab\n111 222 代码 代码块 使用三个反引号加语言名包裹代码\n1 2 3 4 5 6 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ cout\u0026lt;\u0026lt;\u0026#34;hello world\u0026#34;; return 0; } 行内代码 使用反引号包裹\nprint(a)\n数学公式 使用 $$ 包裹 latex 表达式：\n$$ 2\\sqrt{a}x $$行内数学公式 使用单个 $ 包裹： $x=1$\n表格 冒号位置对应对齐方式\n:--- 表示左对齐 ---: 表示右对齐 :---: 表示居中对齐 左对齐 右对齐 居中对齐 abc 123 中间 脚注 脚注示例[^1]\n[^1]: 这里是脚注解释内容。\n脚注示例1\n链接 普通链接 1 [链接文字](链接地址 \u0026#34;鼠标停留文本\u0026#34;) 谷歌\n引用链接 1 [链接文字][引用名] 文末写 [引用名]: 链接地址 \u0026quot;鼠标停留文本\u0026quot;\n谷歌\n跳转标题 跳转到 [标题](#标题文本)\n跳转到前言\n图片 1 ![图片名称](图片路径 \u0026#34;鼠标停留文本\u0026#34;) 其他 横线 ---\n转义 使用 \\ 进行转义，如 \\* 表示普通星号\n斜体 *斜体内容*\n加粗 **加粗内容**\n下划线 1 \u0026lt;u\u0026gt;下划线\u0026lt;/u\u0026gt; 表情 \u0026#x1f604; :smile: 这种格式\n上下标 上标：\u0026lt;sup\u0026gt;上标\u0026lt;/sup\u0026gt;\n下标：\u0026lt;sub\u0026gt;下标\u0026lt;/sub\u0026gt;\n注：属于 HTML 标签，部分平台可能不支持。\n删除线 1 ~~删除线内容~~ 这里是脚注解释内容。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-06-22T19:39:59+08:00","image":"https://Thaumazein.github.io/images/md0.jpg","permalink":"https://Thaumazein.github.io/post/myfirstblog/","title":"我的第一篇博客——Markdown基础语法"}]